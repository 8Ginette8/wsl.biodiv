% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wsl_evaluate_pres.R
\name{wsl.evaluate.pres}
\alias{wsl.evaluate.pres}
\title{Evaluate presence-only models}
\usage{
wsl.evaluate.pres(
  x,
  tester = data.frame(),
  env_vars,
  window = NULL,
  thres = numeric(),
  pres_abs = FALSE,
  log_trans = TRUE,
  speedup = FALSE,
  env_samp = 5000,
  bias_cov = NULL,
  ...
)
}
\arguments{
\item{x}{A wsl.ppm fit object}

\item{tester}{Optional. A data.frame with testing data. Only mandatory if replicatetype='none'
was chosen when models were fitted. Otherwise, used when evaluation against external dataset is needed.
Must be a data.frame with as columns in order: "x", "y", "Presence" ('0' and '1'), "CV" (numeric: chosen
cv-folds; if replicatetype='none' -> only '1') and associated environmental values (same ones as
for fitted models; i.e. same columns order and names). Note that categorical predictor values must
be of class factor. NB: Here, model evaluation will only be initiated for the new testing data.}

\item{env_vars}{Same spatial layers used in the fitted model or an object of class 'data.frame' or 
'matrix' defining a sample of the target layers by keeping same order for columns. If spatial layers
are used, object of class 'RasterStack' or RasterBrick'.}

\item{thres}{Vector of the same length as the number of reps in model fit object}

\item{pres_abs}{Logical. If TRUE, evaluation metrics of presence-only models is applied to a wsl.fit
object of presence-absence models}

\item{log_trans}{Logical. Use only if pres_abs=FALSE. Should predictions be converted to logarithm
before evaluation? Prevent model evaluation errors.}

\item{speedup}{If env_vars is a 'RasterStack' or RasterBrick', should the boyce evaluation be faster?
If TRUE, the algortihm uses a sample of the environmental layers}

\item{env_samp}{If speedup=TRUE, how many environmental cells should be sampled with replacement?
Default is 50'000 samples. The sample may be smaller than requested because of NAs}

\item{bias_cov}{A numerical vector whose length equal the number of environmental layers/columns.
Only used when a bias covariate is implemented in the PPM calibration i.e. to fit species observations
with a potential spatial observer bias. Default is 1 for each variable, whereas designated bias
covariate(s) (i.e. 0) will be reset everywhere to zero in order to evaluate corrected predictions}

\item{...}{Additional arguments supplied to ecospat.boyce function (package 'ecospat')}
}
\value{
an object of class 'wsl.evaluation'. If in slot "performance" NA as thresholds are found,
it indicates a lack of convergence in the model tested, and so, a biased/invalid threshold
}
\description{
Assess model skill metrics for presence-only models in a wsl.fit object. Currently
Boyce index is evaluated. Furthermore, the threshold applied is returned.
}
\examples{


### Load

data(AlpineConvention_lonlat)
data(exrst)
rst = rst[[1:6]]
data(xy_ppm)
mypoints = xy.ppm[,c("x","y")]

### Define mask

maskR = mask(rst[[1]],shp.lonlat)

### Run 'wsl.ppm.window' function

wind = wsl.ppm.window(mask = maskR,
                      val = 1,
                      owin = TRUE)

### Define quadrature points for 'wsl.ppmGlasso'

   # Grid regular
quadG1 = wsl.quadrature(mask = maskR,
                        area.win = wind,
                        random = FALSE,
                        lasso = TRUE,
                        env_vars = rst)

### Define your environments

   # For 'wsl.ppmGlasso' (observations focus)
envG = raster::extract(rst,mypoints)

### Modelling

   # 'wsl.ppmGlasso' (alpha = 0.5 => Elastic net, see package 'glmnet')
       # Complex PPPM lasso (poly = TRUE & lasso=TRUE)

ppm.lasso = wsl.ppmGlasso(pres = mypoints,
                       quadPoints = quadG1,
                       asurface = raster::area(shp.lonlat)/1000,
                       env_vars = envG,
                       taxon = "species_eg1",
                       replicatetype = "cv",
                       reps = 5,
                       strata = NA,
                       save=FALSE,
                       project = "lasso_eg1",
                       path = NA,
                       poly = TRUE,
                       lasso = TRUE,
                       alpha = 0.5,
                       type.measure = "mse",
                       standardize = TRUE,
                       nfolds = 5,
                       nlambda = 100)

       # Simple PPPM non lasso (poly = FALSE & lasso=FALSE)

ppm.simple = wsl.ppmGlasso(pres = mypoints,
                       quadPoints = quadG1,
                       asurface = raster::area(shp.lonlat)/1000,
                       env_vars = envG,
                       taxon = "species_eg2",
                       replicatetype = "cv",
                       reps = 5,
                       strata = NA,
                       save = FALSE,
                       project = "lasso_eg2",
                       path = NA,
                       poly = FALSE,
                       lasso = FALSE)

### Evaluation

   # Example for 'wsl.ppmGlasso'

eval1 = wsl.evaluate.pres(x = ppm.lasso,
                          env_vars = rst)

eval2 = wsl.evaluate.pres(x = ppm.simple,,
                          env_vars = rst,
                          thres = 0.001)

summmary(eval1)
summary(eval2)

}
\author{
Yohann Chauvier, Philipp Brun
}
