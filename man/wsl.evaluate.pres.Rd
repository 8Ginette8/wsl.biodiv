% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wsl_evaluate_pres.R
\name{wsl.evaluate.pres}
\alias{wsl.evaluate.pres}
\title{Evaluate presence-only models}
\usage{
wsl.evaluate.pres(
  x,
  tester = data.frame(),
  env_vars,
  window = NULL,
  thres = numeric(),
  pres_abs = FALSE,
  log_trans = TRUE,
  speedup = FALSE,
  env_samp = 5000,
  bias_cov = NULL,
  ...
)
}
\arguments{
\item{x}{A wsl.ppm fit object}

\item{tester}{Optional. A data.frame with testing data. Only mandatory if replicatetype='none'
was chosen when models were fitted. Otherwise, used when evaluation against external dataset is needed.
Must be a data.frame with as columns in order: "x", "y", "Presence" ('0' and '1'), "CV" (numeric: chosen
cv-folds; if replicatetype='none' -> only '1') and associated environmental values (same ones as
for fitted models; i.e. same columns order and names). Note that categorical predictor values must
be of class factor. NB: Here, model evaluation will only be initiated for the new testing data.}

\item{env_vars}{Same spatial layers used in the fitted model or an object of class 'data.frame' or 
'matrix' defining a sample of the target layers by keeping same order for columns. If spatial layers
are used, object of class 'RasterStack' or RasterBrick'.}

\item{thres}{Vector of the same length as the number of reps in model fit object}

\item{pres_abs}{Logical. If TRUE, evaluation metrics of presence-only models is applied to a wsl.fit
object of presence-absence models}

\item{log_trans}{Logical. Use only if pres_abs=FALSE. Should predictions be converted to logarithm
before evaluation? Prevent model evaluation errors.}

\item{speedup}{If env_vars is a 'RasterStack' or RasterBrick', should the boyce evaluation be faster?
If TRUE, the algortihm uses a sample of the environmental layers}

\item{env_samp}{If speedup=TRUE, how many environmental cells should be sampled with replacement?
Default is 50'000 samples. The sample may be smaller than requested because of NAs}

\item{bias_cov}{A numerical vector whose length equal the number of environmental layers/columns.
Only used when a bias covariate is implemented in the PPM calibration i.e. to fit species observations
with a potential spatial observer bias. Default is 1 for each variable, whereas designated bias
covariate(s) (i.e. 0) will be reset everywhere to zero in order to evaluate corrected predictions}

\item{...}{Additional arguments supplied to ecospat.boyce function (package 'ecospat')}
}
\value{
an object of class 'wsl.evaluation'. If in slot "performance" NA as thresholds are found,
it indicates a lack of convergence in the model tested, and so, a biased/invalid threshold
}
\description{
Assess model skill metrics for presence-only models in a wsl.fit object. Currently
Boyce index is evaluated. Furthermore, the threshold applied is returned.
}
\examples{

# Load
data(AlpineConvention_lonlat)
data(exrst)
rst = rst[[1:6]]
data(xy_ppm)
mypoints = xy.ppm[,c("x","y")]

# Define mask
maskR = mask(rst[[1]],shp.lonlat)

# Run 'wsl.ppm.window' function
wind = wsl.ppm.window(mask = maskR,
                      val = 1,
                      owin = TRUE)

# nDefine quadrature points for 'wsl.ppmGlasso'
quadG1 = wsl.quadrature(mask = maskR,
                        area.win = wind,
                        random = FALSE,
                        lasso = TRUE,
                        env_vars = rst)

# Define your environments
envG = raster::extract(rst,mypoints)

# Spatial block cross-validation
to_b_xy = rbind(mypoints,quadG1@coords)
toSamp = c(rep(1,nrow(mypoints)),rep(0,nrow(quadG1@coords)))
block_cv_xy = make_blocks(nstrat = 5, df = to_b_xy, nclusters = 10, pres = toSamp)

# 'wsl.ppmGlasso' (alpha = 0.5 => Elastic net, see package 'glmnet')
   # Complex PPP lasso (poly = TRUE & lasso=TRUE)
ppm.lasso = wsl.ppmGlasso(pres = mypoints,
                       quadPoints = quadG1,
                       asurface = raster::area(shp.lonlat)/1000,
                       env_vars = envG,
                       taxon = "species_eg1",
                       replicatetype = "cv",
                       reps = 5,
                       strata = NA,
                       save=FALSE,
                       project = "lasso_eg1",
                       path = NA,
                       poly = TRUE,
                       lasso = TRUE,
                       alpha = 0.5,
                       type.measure = "mse",
                       standardize = TRUE,
                       nfolds = 5,
                       nlambda = 100)
summary(ppm.lasso)

  # Simple PPP (poly = FALSE & lasso=FALSE) + block-cross validation
ppm.simple = wsl.ppmGlasso(pres = mypoints,
                       quadPoints = quadG1,
                       asurface = raster::area(shp.lonlat)/1000,
                       env_vars = envG,
                       taxon = "species_eg2",
                       replicatetype = "block-cv",
                       reps = 5,
                       strata = block_cv_xy,
                       save = FALSE,
                       project = "lasso_eg2",
                       path = NA,
                       poly = FALSE,
                       lasso = FALSE)
summary(ppm.simple)

### Evaluation
eval1 = wsl.evaluate.pres(x = ppm.lasso,
                          env_vars = rst)
eval2 = wsl.evaluate.pres(x = ppm.simple,
                          env_vars = rst,
                          thres = 0.001,
                          speedup = TRUE,
                          bias_cov=c(1,0,0,0,1,1))
eval3 = wsl.evaluate.pa(x = ppm.lasso,
                        crit="maxTSS",
                        pres_only = TRUE,
                        bias_cov=c(1,0,0,1,1,0))
eval4 = wsl.evaluate.pa(x = ppm.simple,
                       crit="pp=op",
                       pres_only = TRUE)
summary(eval1)
summary(eval2)
summary(eval3)
summary(eval4)

### Thresholds
get_thres(eval1, mean = FALSE)
get_thres(eval2, mean = TRUE)
get_thres(eval3, mean = TRUE)
get_thres(eval4, mean = FALSE)

}
\author{
Yohann Chauvier, Philipp Brun
}
